# -----------------------------------------------------------------------------
# poc-credential-rotator — GitHub Actions Workflow (PoC)
#
# WHAT THIS DOES
# - On pushes to and PRs targeting branch "proofofconcept":
#   * Lints/validates Terraform for AWS & OCI
#   * Builds the rotation worker container (no push on PRs)
#   * (PoC) Generates SBOM and runs a vuln scan (non-blocking)
# - On pushes (not PRs):
#   * Logs into ECR (OIDC) and OCIR, pushes the image
#   * Resolves immutable digests and prints pinned URIs
#   * Creates a PR pinning Terraform to image digests for deterministic deploys
#
# SECURITY & OPS NOTES (PoC)
# - Uses GitHub OIDC to assume AWS role (no long-lived creds) — set AWS_OIDC_ROLE_ARN.
# - OCIR login requires per-user Auth Token secret (short-lived recommended).
# - SBOM & Trivy are optional here (non-fatal); make them blocking gates for production.
# - Concurrency guard prevents overlapping runs per ref (avoids double-push races).
#
# TUNABLES
# - Branch filters, platform (linux/amd64), Terraform version, and scanners can be changed below.
# -----------------------------------------------------------------------------

name: poc-credential-rotator

on:
  push:
    branches: [ "proofofconcept" ]              # Trigger on direct pushes to PoC branch
  pull_request:
    branches: [ "proofofconcept" ]              # Trigger on PRs targeting PoC branch

# Avoid overlapping runs for the same ref (prevents duplicate pushes)
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  IMAGE_NAME: rotator                             # Tunable: repository name for both ECR/OCIR
  PLATFORM: linux/amd64                           # Keep Lambda/OCI Functions parity

jobs:
  # ---------------------------------------------------------------------------
  # Job 1: Lint & Validate (always runs on PRs and pushes)
  # ---------------------------------------------------------------------------
  lint-validate:
    name: Lint & Validate (Dockerfile/Terraform)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Produce a canonical short tag for this commit
      - name: Docker metadata (tag)
        id: meta
        run: echo "TAG=$(git rev-parse --short=12 HEAD)" >> $GITHUB_OUTPUT

      # Terraform toolchain — pinned for reproducibility
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.5

      # Enforce formatting and validate (AWS stack)
      - name: terraform fmt (aws)
        working-directory: infra/aws
        run: terraform fmt -check -recursive

      - name: terraform validate (aws)
        working-directory: infra/aws
        run: terraform init -backend=false && terraform validate

      # Enforce formatting and validate (OCI stack)
      - name: terraform fmt (oci)
        working-directory: infra/oci
        run: terraform fmt -check -recursive

      - name: terraform validate (oci)
        working-directory: infra/oci
        run: terraform init -backend=false && terraform validate

      # Build container for parity checks; PRs do not push
      - name: Build container (no push on PR)
        run: docker buildx build --platform ${{ env.PLATFORM }} -t ${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.TAG }} infra/shared/image

      # ---- Optional PoC supply-chain hooks (non-fatal here) ----
      - name: (PoC) SBOM with syft
        continue-on-error: true                    # Production: remove to fail on SBOM errors
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.TAG }}
          format: spdx-json
          output-file: sbom-${{ env.IMAGE_NAME }}-${{ steps.meta.outputs.TAG }}.spdx.json

      - name: (PoC) Trivy image scan
        continue-on-error: true                    # Production: fail on HIGH/CRITICAL
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.TAG }}
          format: table
          ignore-unfixed: true
          vuln-type: 'os,library'
          severity: 'HIGH,CRITICAL'

      - name: Upload SBOM artifact (PoC)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ steps.meta.outputs.TAG }}
          path: sbom-${{ env.IMAGE_NAME }}-${{ steps.meta.outputs.TAG }}.spdx.json
          if-no-files-found: ignore

  # ---------------------------------------------------------------------------
  # Job 2: Push images to ECR & OCIR + resolve digests (push-only)
  # ---------------------------------------------------------------------------
  push-images:
    name: Push Images (ECR & OCIR on push only)
    runs-on: ubuntu-latest
    needs: [lint-validate]
    if: github.event_name == 'push'               # Do not push on PRs
    permissions:
      id-token: write                             # OIDC to AWS (no static creds)
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set VERSION
        id: vars
        run: echo "VERSION=$(git rev-parse --short=12 HEAD)" >> $GITHUB_OUTPUT

      # ---------- AWS ECR (OIDC) ----------
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}   # Required secret
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Derive ECR repo URI
        id: ecr
        run: echo "ECR_REPO=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/${{ env.IMAGE_NAME }}" >> $GITHUB_OUTPUT

      # ---------- OCI OCIR ----------
      - name: Login to OCIR
        env:
          OCIR_USERNAME: ${{ secrets.OCIR_USERNAME }}         # Use auth token; prefer short-lived
          OCIR_AUTH_TOKEN: ${{ secrets.OCIR_AUTH_TOKEN }}
          OCIR_REGION: ${{ secrets.OCIR_REGION }}
          OCIR_TENANCY_NAMESPACE: ${{ secrets.OCIR_TENANCY_NAMESPACE }}
        run: echo "${OCIR_AUTH_TOKEN}" | docker login "${OCIR_REGION}.ocir.io" -u "${OCIR_TENANCY_NAMESPACE}/${OCIR_USERNAME}" --password-stdin

      # Build once, push to both registries
      - name: Build image (push job)
        run: docker buildx build --platform ${{ env.PLATFORM }} -t ${{ env.IMAGE_NAME }}:${{ steps.vars.outputs.VERSION }} infra/shared/image

      - name: Tag & push to ECR
        run: |
          docker tag ${{ env.IMAGE_NAME }}:${{ steps.vars.outputs.VERSION }} ${{ steps.ecr.outputs.ECR_REPO }}:${{ steps.vars.outputs.VERSION }}
          docker push ${{ steps.ecr.outputs.ECR_REPO }}:${{ steps.vars.outputs.VERSION }}

      - name: Tag & push to OCIR
        env:
          OCIR_REGION: ${{ secrets.OCIR_REGION }}
          OCIR_TENANCY_NAMESPACE: ${{ secrets.OCIR_TENANCY_NAMESPACE }}
        run: |
          OCIR_REPO="${OCIR_REGION}.ocir.io/${OCIR_TENANCY_NAMESPACE}/${{ env.IMAGE_NAME }}"
          docker tag ${{ env.IMAGE_NAME }}:${{ steps.vars.outputs.VERSION }} ${OCIR_REPO}:${{ steps.vars.outputs.VERSION }}
          docker push ${OCIR_REPO}:${{ steps.vars.outputs.VERSION }}
          echo "OCIR_REPO=${OCIR_REPO}" >> $GITHUB_OUTPUT

      # Resolve immutable digests (pinning for deterministic deploys)
      - name: Resolve image digests
        id: digests
        env:
          ECR_REPO: ${{ steps.ecr.outputs.ECR_REPO }}
          VERSION: ${{ steps.vars.outputs.VERSION }}
          OCIR_REPO: ${{ steps.tag___push_to_OCIR.OCIR_REPO }}  # from previous step
        run: |
          # ECR digest from AWS API
          ECR_DIGEST=$(aws ecr describe-images --repository-name "${ECR_REPO##*/}" --image-ids imageTag="${VERSION}" --query 'imageDetails[0].imageDigest' --output text)
          echo "ECR_DIGEST=${ECR_DIGEST}" >> $GITHUB_OUTPUT
          echo "ECR_IMAGE_URI=${ECR_REPO}@${ECR_DIGEST}" >> $GITHUB_OUTPUT
          # OCIR digest from local inspect
          OCIR_TAGGED="${{ secrets.OCIR_REGION }}.ocir.io/${{ secrets.OCIR_TENANCY_NAMESPACE }}/${{ env.IMAGE_NAME }}:${VERSION}"
          OCIR_REPO_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "${OCIR_TAGGED}")
          OCIR_DIGEST="${OCIR_REPO_DIGEST#*@}"
          echo "OCIR_DIGEST=${OCIR_DIGEST}" >> $GITHUB_OUTPUT
          echo "OCIR_IMAGE_URI=${{ secrets.OCIR_REGION }}.ocir.io/${{ secrets.OCIR_TENANCY_NAMESPACE }}/${{ env.IMAGE_NAME }}@${OCIR_DIGEST}" >> $GITHUB_OUTPUT

      - name: Output image URIs
        run: |
          echo "ECR pinned:  ${{ steps.digests.outputs.ECR_IMAGE_URI }}"
          echo "OCIR pinned: ${{ steps.digests.outputs.OCIR_IMAGE_URI }}"

      # Artifact for auditability (keeps IaC + build context handy)
      - name: Upload digests artifact
        uses: actions/upload-artifact@v4
        with:
          name: image-digests-${{ steps.vars.outputs.VERSION }}
          path: |
            **/infra/aws/**
            **/infra/oci/**
          if-no-files-found: ignore

  # ---------------------------------------------------------------------------
  # Job 3: Create PR to pin Terraform to digests (push-only)
  # ---------------------------------------------------------------------------
  pin-digests-pr:
    name: Create PR to pin Terraform to digests
    runs-on: ubuntu-latest
    needs: [push-images]
    if: github.event_name == 'push'
    permissions:
      contents: write                                  # Needed to push branch
      pull-requests: write                             # Needed to open PR
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set VERSION & BRANCH
        id: vars
        run: |
          echo "VERSION=$(git rev-parse --short=12 HEAD)" >> $GITHUB_OUTPUT
          echo "BRANCH=poc/digest-pin-${{ github.run_number }}-${{ github.run_attempt }}" >> $GITHUB_OUTPUT

      # Fallback computation of URIs in this job context
      - name: Compute URIs (fallback when outputs are not exposed cross-jobs)
        id: compute
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
          OCIR_REGION: ${{ secrets.OCIR_REGION }}
          OCIR_TENANCY_NAMESPACE: ${{ secrets.OCIR_TENANCY_NAMESPACE }}
          VERSION: ${{ steps.vars.outputs.VERSION }}
        run: |
          ECR_REPO="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${{ env.IMAGE_NAME }}"
          ECR_DIGEST=$(aws ecr describe-images --repository-name "${{ env.IMAGE_NAME }}" --image-ids imageTag="${VERSION}" --query 'imageDetails[0].imageDigest' --output text)
          echo "ECR_IMAGE_URI=${ECR_REPO}@${ECR_DIGEST}" >> $GITHUB_OUTPUT
          OCIR_TAGGED="${OCIR_REGION}.ocir.io/${OCIR_TENANCY_NAMESPACE}/${{ env.IMAGE_NAME }}:${VERSION}"
          OCIR_REPO_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "${OCIR_TAGGED}" || true)
          if [ -z "${OCIR_REPO_DIGEST}" ]; then
            # Pull image to compute digest locally (avoids registry API divergence)
            docker pull "${OCIR_TAGGED}"
            OCIR_REPO_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "${OCIR_TAGGED}")
          fi
          OCIR_DIGEST="${OCIR_REPO_DIGEST#*@}"
          echo "OCIR_IMAGE_URI=${OCIR_REGION}.ocir.io/${OCIR_TENANCY_NAMESPACE}/${{ env.IMAGE_NAME }}@${OCIR_DIGEST}" >> $GITHUB_OUTPUT

      - name: Create branch with pinned URIs
        run: |
          git checkout -b "${{ steps.vars.outputs.BRANCH }}"
          mkdir -p infra/aws infra/oci
          cat > infra/aws/terraform.auto.tfvars <<EOF
ecr_image_uri = "${{ steps.compute.outputs.ECR_IMAGE_URI }}"
EOF
          cat > infra/oci/terraform.auto.tfvars <<EOF
ocir_image_uri = "${{ steps.compute.outputs.OCIR_IMAGE_URI }}"
EOF
          git add infra/aws/terraform.auto.tfvars infra/oci/terraform.auto.tfvars
          git commit -m "chore: pin images to digests (ECR/OCIR) for ${{ steps.vars.outputs.VERSION }}"

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v6
        with:
          branch: ${{ steps.vars.outputs.BRANCH }}
          title: "Pin images to digests for ${{ steps.vars.outputs.VERSION }}"
          body: |
            This PR pins the deployment images to immutable **digests**:
            - ECR:  `${{ steps.compute.outputs.ECR_IMAGE_URI }}`
            - OCIR: `${{ steps.compute.outputs.OCIR_IMAGE_URI }}`
            Rationale:
            - Prevent supply-chain drift (immutable deploys)
            - Enable deterministic rollbacks
          commit-message: "chore: pin images to digests for ${{ steps.vars.outputs.VERSION }}"
