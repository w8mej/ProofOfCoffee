# =============================================================================
# k8s/frost-secrets.yaml â€” JWT & TLS Secrets (documented)
#
# Security & Ops
# - Contains **two secrets**:
#   1. frost-secrets: stores JWT HS256 signing key (base64-encoded)
#   2. frost-tls: stores TLS certificate, private key, and CA bundle for mTLS
#
# - These secrets are consumed by both `frost-coordinator` and `frost-signer` pods.
#   - `JWT_HS256_B64` is mounted read-only at `/jwt/JWT_HS256_B64`.
#   - TLS secrets are mounted read-only at `/tls` to secure RPC traffic.
#
# - **mTLS**: The CA bundle (`ca.crt`) enables mutual authentication between coordinator
#   and signer pods, and optionally upstream services like OPA or Envoy.
#
# Tunables / Config
# - JWT_HS256_B64: This is the **base64 of the raw HS256 secret**, not the key's hex.
#   Regenerate with: `head -c32 /dev/urandom | base64` for 256-bit secret.
# - TLS PEMs: Populate `tls.crt` and `tls.key` with valid ECDSA cert and key (256-bit
#   for production). Include `ca.crt` to enable mTLS verification.
#
# Operational Guidance
# - Store sensitive values outside git; generate via `kubectl create secret ...` or
#   integrate with an external secrets manager (e.g., Vault, AWS/GCP/OCI Secrets).
# - Rotate both JWT and TLS secrets periodically:
#     - JWT: Rotate on credential compromise or policy interval (e.g., 90 days).
#     - TLS: Match `cert-manager` rotation or CA expiration policy.
# - For staging/testing, you may use self-signed TLS certs, but for production,
#   use an internal CA or cert-manager automation with a trusted issuer.
#
# Production Considerations
# - Limit secret access via RBAC:
#     - Only workloads needing the secret should have `get`/`list` privileges.
#     - Use separate service accounts per role and namespace-level RoleBindings.
# - Prefer ephemeral pod volumes (e.g., CSI Secret Store) over static Secrets for
#   high-security deployments.
# - Audit `kubectl get secret` usage; ensure API server logs are collected.
# - Consider enabling encryption at rest for secrets in the cluster (KMS-backed).
# =============================================================================

---
# JWT secret: base64-encoded HS256 key used for signing/verifying RPC messages.
# Example generation: head -c32 /dev/urandom | base64
apiVersion: v1
kind: Secret
metadata:
  name: frost-secrets
  namespace: frost
type: Opaque
stringData:
  JWT_HS256_B64: "ZGV2c2VjcmV0"  # base64 of HS256 secret

---
# TLS secret: cert + key for mTLS between coordinator/signers (and optionally OPA).
# Populate with base64-encoded PEMs; leave empty in manifests if cert-manager will fill.
apiVersion: v1
kind: Secret
metadata:
  name: frost-tls
  namespace: frost
type: kubernetes.io/tls
data:
  # base64-encoded PEMs; for mTLS include a CA bundle.
  tls.crt: ""   # base64 of certificate PEM
  tls.key: ""   # base64 of private key PEM
  ca.crt:  ""   # base64 of CA bundle PEM (optional if using cert-manager issuer)