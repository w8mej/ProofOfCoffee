# docker-compose.yml — Local PoC topology for Zero-Trust Minting (documented)
#
# Overview
# --------
# This compose file spins up:
#   • mint-api (FastAPI) — the token minting API (not shown here; built elsewhere)
#   • frost-keygen       — one-shot key dealer that generates FROST state into ./frost_state
#   • frost-signer-[1..3]— signer daemons reading their KeyPackage from ./frost_state
#   • frost-coordinator  — aggregates partial signatures over mTLS/JWT and exposes /sign
#
# Flow (PoC):
#   mint-api → frost-coordinator (/sign) → frost-signer-* (partial sigs) → aggregate Ed25519
#
# Security & Ops
# --------------
# • Principle of least privilege: all containers drop Linux caps, run as non-root UID/GID 10001,
#   and have read-only filesystems where possible.
# • Secrets: For a PoC, no secrets are mounted here. In real deployments, mount mTLS materials
#   and HS256 auth tokens from secrets (e.g., Docker/Compose secrets or K8s).
# • Healthchecks: Each service has an HTTP healthcheck; ensure images include wget or curl.
# • Networking: All services bind to 127.0.0.1 to keep ports local to the host.
# • Startup order: signers depend on keygen; coordinator depends on signers.
#
# Tunables / Config
# -----------------
# • FROST_N / FROST_T: dealer count and threshold (default 3-of-2).
# • Port mapping: tweak host bindings if ports conflict.
# • Image names: replace ghcr.io/your-org/* with your registry paths and digests.
# • frost_state volume: persists generated shares for repeat runs (clean between tests).
#
# Production Considerations
# -------------------------
# • Do not use docker-compose for production. Deploy signers on private networks (K8s DaemonSet
#   or separate CVMs), enforce mTLS + JWT auth, and restrict egress with NetworkPolicies/NSGs.
# • Replace wget healthchecks with a tiny static binary baked into images (busybox curl or /healthz).
# • Pass HS256 key via a secret file (JWT_HS256_B64_FILE) and mount mTLS certs (/tls).
# • Ensure coordinator only reaches signers over mTLS; in compose, this is a single network
#   so we omit TLS for brevity. Keep TLS in your real images even in dev.

version: "3.8"

services:
  mint-api:
    image: ghcr.io/your-org/mpc-minting:latest
    # NOTE: If your mint-api depends on frost-coordinator, set COORDINATOR_URL env.
    ports:
      - "127.0.0.1:8080:8080"
    security_opt: ["no-new-privileges:true"]
    cap_drop: ["ALL"]
    read_only: true
    user: "10001:10001"
    # In production, mount:
    #   - ./secrets/jwt:/jwt:ro            (contains JWT_HS256_B64)
    #   - ./secrets/tls:/tls:ro            (mTLS materials)
    #   - ./policy.json:/app/policy.json:ro
    environment:
      # Example: point at local coordinator
      - COORDINATOR_URL=http://frost-coordinator:7100
      # Optional policy path:
      # - POLICY_FILE=/app/policy.json
    depends_on:
      - frost-coordinator
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://127.0.0.1:8080/healthz"]
      interval: 30s
      timeout: 5s
      retries: 3

  frost-keygen:
    # Builds the Rust multi-binary image (frost-keygen/signer/coordinator) from ./frost
    build:
      context: ./frost
    image: ghcr.io/your-org/frost:latest
    command: ["/usr/local/bin/frost-keygen"]
    environment:
      - FROST_N=3
      - FROST_T=2
      - FROST_OUT=/app/frost_state
    volumes:
      - ./frost_state:/app/frost_state
    security_opt: ["no-new-privileges:true"]
    cap_drop: ["ALL"]
    read_only: false      # writes initial shares to /app/frost_state
    user: "10001:10001"
    # Keygen is a batch job; no healthcheck required. Kept for uniformity.
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://127.0.0.1:7000/healthz"]
      interval: 30s
      timeout: 5s
      retries: 3

  frost-signer-1:
    image: ghcr.io/your-org/frost:latest
    depends_on: [frost-keygen]
    command: ["/usr/local/bin/frost-signer"]
    environment:
      - SIGNER_ID=1
      - BIND=0.0.0.0:7001
      - FROST_STATE=/app/frost_state
      # In prod:
      # - TLS_CERT_PEM=/tls/tls.crt
      # - TLS_KEY_PEM=/tls/tls.key
      # - TLS_CLIENT_CA=/tls/ca.crt
      # - JWT_HS256_B64_FILE=/jwt/JWT_HS256_B64
    volumes:
      - ./frost_state:/app/frost_state:ro
      # - ./secrets/tls:/tls:ro
      # - ./secrets/jwt:/jwt:ro
    ports:
      - "127.0.0.1:7001:7001"
    security_opt: ["no-new-privileges:true"]
    cap_drop: ["ALL"]
    read_only: true
    user: "10001:10001"
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://127.0.0.1:7001/healthz"]
      interval: 30s
      timeout: 5s
      retries: 3

  frost-signer-2:
    image: ghcr.io/your-org/frost:latest
    depends_on: [frost-keygen]
    command: ["/usr/local/bin/frost-signer"]
    environment:
      - SIGNER_ID=2
      - BIND=0.0.0.0:7002
      - FROST_STATE=/app/frost_state
    volumes:
      - ./frost_state:/app/frost_state:ro
    ports:
      - "127.0.0.1:7002:7002"
    security_opt: ["no-new-privileges:true"]
    cap_drop: ["ALL"]
    read_only: true
    user: "10001:10001"
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://127.0.0.1:7002/healthz"]
      interval: 30s
      timeout: 5s
      retries: 3

  frost-signer-3:
    image: ghcr.io/your-org/frost:latest
    depends_on: [frost-keygen]
    command: ["/usr/local/bin/frost-signer"]
    environment:
      - SIGNER_ID=3
      - BIND=0.0.0.0:7003
      - FROST_STATE=/app/frost_state
    volumes:
      - ./frost_state:/app/frost_state:ro
    ports:
      - "127.0.0.1:7003:7003"
    security_opt: ["no-new-privileges:true"]
    cap_drop: ["ALL"]
    read_only: true
    user: "10001:10001"
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://127.0.0.1:7003/healthz"]
      interval: 30s
      timeout: 5s
      retries: 3

  frost-coordinator:
    image: ghcr.io/your-org/frost:latest
    depends_on: [frost-signer-1, frost-signer-2]
    command: ["/usr/local/bin/frost-coordinator"]
    environment:
      - BIND=0.0.0.0:7100
      - FROST_STATE=/app/frost_state
      # In prod:
      # - TLS_CERT_PEM=/tls/tls.crt
      # - TLS_KEY_PEM=/tls/tls.key
      # - TLS_SERVER_CA=/tls/ca.crt   # trust signer CAs
      # - JWT_HS256_B64_FILE=/jwt/JWT_HS256_B64
    volumes:
      - ./frost_state:/app/frost_state:ro
      # - ./secrets/tls:/tls:ro
      # - ./secrets/jwt:/jwt:ro
    ports:
      - "127.0.0.1:7100:7100"
    security_opt: ["no-new-privileges:true"]
    cap_drop: ["ALL"]
    read_only: true
    user: "10001:10001"
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://127.0.0.1:7100/healthz"]
      interval: 30s
      timeout: 5s
      retries: 3

# Optional: declare a named network if you want to isolate traffic; default network is fine for local dev.
# networks:
#   default:
#     name: frost-net
#     driver: bridge

# Volumes:
#   • ./frost_state persists the generated dealer state and signer shares across runs.
#     Clean it between tests if you need fresh keys.